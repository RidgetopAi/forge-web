<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Forge Live - Knowledge Graph Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            min-height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif;
            color: #ffffff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(0, 212, 255, 0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.2rem;
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 0.9rem;
            color: #64748b;
        }

        .overlay {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        .title {
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00f5d4 0%, #00d4ff 25%, #0ea5e9 50%, #7c3aed 75%, #ec4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #64748b;
            font-weight: 300;
            letter-spacing: 0.05em;
        }

        .stats {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(0, 212, 255, 0.2);
            padding: 20px;
            border-radius: 12px;
            font-size: 0.85rem;
            color: #64748b;
            backdrop-filter: blur(15px);
            min-width: 200px;
        }

        .stats .stat-row {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }

        .stats .stat-row:last-child {
            margin-bottom: 0;
        }

        .stats .stat-label {
            color: #64748b;
        }

        .stats .stat-value {
            color: #00d4ff;
            font-weight: 600;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(0, 212, 255, 0.2);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            z-index: 10;
        }

        .controls button {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #00d4ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 5px;
        }

        .controls button:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .controls button.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Knowledge Graph</div>
        <div class="loading-progress">Initializing...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="overlay">
        <h1 class="title">The Forge Live</h1>
        <p class="subtitle" id="subtitle">Loading...</p>
    </div>

    <div class="controls">
        <button id="auto-rotate-btn" class="active">Auto Rotate</button>
        <button id="reset-camera-btn">Reset Camera</button>
    </div>

    <div class="stats">
        <div class="stat-row">
            <span class="stat-label">Contexts:</span>
            <span class="stat-value" id="context-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Projects:</span>
            <span class="stat-value" id="project-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Particles:</span>
            <span class="stat-value" id="particle-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">FPS:</span>
            <span class="stat-value" id="fps-count">60</span>
        </div>
    </div>

    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1/dist/es-module-shims.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // Global state
        let scene, camera, renderer, controls, composer;
        let nodes = [];
        let particles = [];
        let ripples = [];
        let contexts = [];
        let connections = [];
        let autoRotate = true;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let frameCountLastSecond = 60;
        let time = 0;
        let GLOW_TEX = null;

        // Configuration (adaptive)
        let MAX_PARTICLES = 80;
        let PARTICLE_SPAWN_RATE = 80; // ms between spawns

        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 40, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 35);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: 'high-performance',
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1); // Force iGPU-friendly DPR
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 80;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x00d4ff, 0.6, 100);
            pointLight1.position.set(20, 20, 20);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xec4899, 0.6, 100);
            pointLight2.position.set(-20, -20, -20);
            scene.add(pointLight2);

            // Post-processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.7,   // strength (reduced for clarity)
                0.4,   // radius
                0.78   // threshold (higher = only bright things glow)
            );
            composer.addPass(bloomPass);
            window.bloomPass = bloomPass; // For adaptive adjustment

            // FXAA for crisp thin lines
            const fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.material.uniforms['resolution'].value.set(
                1 / window.innerWidth, 
                1 / window.innerHeight
            );
            composer.addPass(fxaaPass);
            window.fxaaPass = fxaaPass;

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            window.fxaaPass.material.uniforms['resolution'].value.set(
                1 / window.innerWidth,
                1 / window.innerHeight
            );
        }

        // Create glow texture for particles
        function makeGlowTexture(size = 32) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, size, size);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.LinearFilter;
            tex.minFilter = THREE.LinearMipMapLinearFilter;
            return tex;
        }

        // Create subtle starfield
        function createStarfield() {
            const starCount = 400;
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const radius = 60 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                sizes[i] = Math.random() * 1.5 + 0.5;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                color: 0x4466aa,
                size: 0.15,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // Load context data
        async function loadContextData() {
            const loadingProgress = document.querySelector('.loading-progress');

            try {
                loadingProgress.textContent = 'Fetching data...';
                const response = await fetch('./data/contexts.json');
                const data = await response.json();

                loadingProgress.textContent = 'Processing contexts...';
                contexts = data.contexts;

                // Update UI
                document.getElementById('context-count').textContent = data.metadata.total_contexts.toLocaleString();
                document.getElementById('project-count').textContent = data.metadata.projects.length;
                document.getElementById('subtitle').textContent =
                    `${data.metadata.total_contexts.toLocaleString()} contexts • ${data.metadata.projects.length} projects • Living knowledge graph`;

                return data;
            } catch (error) {
                console.error('Error loading context data:', error);
                loadingProgress.textContent = 'Error loading data';
                throw error;
            }
        }

        // K-means clustering
        function kMeansClustering(points, k = 8, maxIterations = 20) {
            const centroids = [];
            const usedIndices = new Set();
            while (centroids.length < k) {
                const idx = Math.floor(Math.random() * points.length);
                if (!usedIndices.has(idx)) {
                    centroids.push([...points[idx]]);
                    usedIndices.add(idx);
                }
            }

            let assignments = new Array(points.length).fill(0);

            for (let iter = 0; iter < maxIterations; iter++) {
                for (let i = 0; i < points.length; i++) {
                    let minDist = Infinity;
                    let bestCluster = 0;

                    for (let j = 0; j < k; j++) {
                        const dist = Math.sqrt(
                            Math.pow(points[i][0] - centroids[j][0], 2) +
                            Math.pow(points[i][1] - centroids[j][1], 2) +
                            Math.pow(points[i][2] - centroids[j][2], 2)
                        );

                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = j;
                        }
                    }

                    assignments[i] = bestCluster;
                }

                const newCentroids = Array(k).fill(null).map(() => [0, 0, 0]);
                const counts = new Array(k).fill(0);

                for (let i = 0; i < points.length; i++) {
                    const cluster = assignments[i];
                    newCentroids[cluster][0] += points[i][0];
                    newCentroids[cluster][1] += points[i][1];
                    newCentroids[cluster][2] += points[i][2];
                    counts[cluster]++;
                }

                for (let j = 0; j < k; j++) {
                    if (counts[j] > 0) {
                        centroids[j][0] = newCentroids[j][0] / counts[j];
                        centroids[j][1] = newCentroids[j][1] / counts[j];
                        centroids[j][2] = newCentroids[j][2] / counts[j];
                    }
                }
            }

            return assignments;
        }

        // Color palette
        function getColorPalette() {
            return [
                new THREE.Color(0x00d4ff), // cyan
                new THREE.Color(0x10b981), // green
                new THREE.Color(0xec4899), // pink
                new THREE.Color(0xf59e0b), // orange
                new THREE.Color(0x7c3aed), // purple
                new THREE.Color(0x00f5d4), // teal
                new THREE.Color(0x0ea5e9), // blue
                new THREE.Color(0xfbbf24), // yellow
            ];
        }

        // Node class with energy orb style (emissive core + Fresnel halo)
        class Node {
            constructor(position, color, index) {
                this.basePosition = position.clone();
                this.position = position.clone();
                this.baseColor = color.clone();
                this.currentColor = color.clone();
                this.index = index;
                this.pulseOffset = Math.random() * Math.PI * 2;
                this.baseSize = 0.16;
                this.currentSize = this.baseSize;
                this.colorInfluences = [];

                // Create energy orb: emissive core + Fresnel halo
                const radius = 1;
                
                // Core sphere (emissive, translucent)
                const coreGeo = new THREE.SphereGeometry(radius, 16, 12);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: this.currentColor.clone().multiplyScalar(0.6),
                    emissive: this.currentColor,
                    emissiveIntensity: 1.2,
                    roughness: 0.35,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.35,
                    depthWrite: false,
                    toneMapped: false
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);

                // Fresnel halo (outer glow)
                const haloGeo = new THREE.SphereGeometry(radius * 1.2, 16, 12);
                const haloMat = new THREE.ShaderMaterial({
                    uniforms: { color: { value: this.currentColor.clone() } },
                    vertexShader: `
                        varying float vF; 
                        void main() {
                            vec3 n = normalize(normalMatrix * normal);
                            vec3 v = normalize((modelViewMatrix * vec4(position,1.0)).xyz);
                            vF = pow(1.0 - max(0.0, dot(n, -v)), 2.0);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                        }`,
                    fragmentShader: `
                        uniform vec3 color; 
                        varying float vF;
                        void main() {
                            float a = smoothstep(0.1, 0.9, vF) * 0.35;
                            gl_FragColor = vec4(color, a);
                        }`,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    side: THREE.BackSide,
                    depthWrite: false,
                    toneMapped: false
                });
                this.halo = new THREE.Mesh(haloGeo, haloMat);

                // Group both meshes
                this.group = new THREE.Group();
                this.group.add(this.core);
                this.group.add(this.halo);
                this.group.position.copy(this.position);
                this.group.scale.setScalar(this.baseSize);
                
                this.mesh = this.group; // Compatibility
                scene.add(this.group);
            }

            addColorInfluence(color, strength = 0.8) {
                this.colorInfluences.push({
                    color: color.clone(),
                    strength: strength,
                    decay: 0.02
                });
            }

            update(deltaTime, cameraPosition) {
                // Gentle floating motion
                this.position.x = this.basePosition.x + Math.sin(time * 0.0005 + this.pulseOffset) * 0.3;
                this.position.y = this.basePosition.y + Math.cos(time * 0.0003 + this.pulseOffset) * 0.3;
                this.position.z = this.basePosition.z + Math.sin(time * 0.0004 + this.pulseOffset) * 0.2;

                // Pulsing
                const t = time * 0.001 + this.index * 0.37;
                const pulse = Math.sin(t) * 0.15 + 0.85;
                this.currentSize = this.baseSize * pulse;

                // Distance to camera for depth dimming
                const dist = this.position.distanceTo(cameraPosition);
                const dim = THREE.MathUtils.clamp(1.0 - (dist - 20) / 60, 0.6, 1.0);

                // Color mixing from influences
                if (this.colorInfluences.length > 0) {
                    let mixedColor = this.baseColor.clone();
                    let totalStrength = 0;

                    for (let i = this.colorInfluences.length - 1; i >= 0; i--) {
                        const influence = this.colorInfluences[i];
                        influence.strength -= influence.decay;

                        if (influence.strength <= 0) {
                            this.colorInfluences.splice(i, 1);
                        } else {
                            totalStrength += influence.strength;
                        }
                    }

                    if (totalStrength > 0) {
                        this.colorInfluences.forEach(influence => {
                            const weight = (influence.strength / totalStrength) * 0.5;
                            mixedColor.lerp(influence.color, weight);
                        });
                        this.currentColor = mixedColor;
                    } else {
                        this.currentColor = this.baseColor.clone();
                    }
                } else {
                    this.currentColor = this.baseColor.clone();
                }

                // Update group position and scale
                this.group.position.copy(this.position);
                this.group.scale.setScalar(this.currentSize);
                
                // Update core material
                this.core.material.color.copy(this.currentColor.clone().multiplyScalar(0.6));
                this.core.material.emissive.copy(this.currentColor);
                this.core.material.emissiveIntensity = (1.2 + Math.sin(t) * 0.15) * dim;
                
                // Update halo color
                this.halo.material.uniforms.color.value.copy(this.currentColor);
            }
        }

        // Traveling Particle class (sprite-based for performance)
        class TravelingParticle {
            constructor(startNode, endNode, color) {
                this.startNode = startNode;
                this.endNode = endNode;
                this.color = color.clone();
                this.progress = 0;
                this.speed = 0.008 + Math.random() * 0.004;
                this.hasArrived = false;

                // Create particle sprite with glow texture
                const spriteMat = new THREE.SpriteMaterial({
                    map: GLOW_TEX,
                    color: color.clone(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false,
                    toneMapped: false
                });
                this.mesh = new THREE.Sprite(spriteMat);
                this.mesh.scale.set(0.12, 0.12, 0.12);
                scene.add(this.mesh);

                // Trail line (shorter for performance)
                const positions = new Float32Array(6);
                const lineGeometry = new THREE.BufferGeometry();
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const lineMaterial = new THREE.LineBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    toneMapped: false
                });

                this.trail = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(this.trail);
            }

            update() {
                this.progress += this.speed;

                if (!this.hasArrived && this.progress >= 0.95) {
                    this.hasArrived = true;
                    this.endNode.addColorInfluence(this.color, 0.9);
                    ripples.push(new Ripple(this.endNode, this.color));
                }

                if (this.progress >= 1.0) return false;

                // Update position
                const pos = new THREE.Vector3().lerpVectors(
                    this.startNode.position,
                    this.endNode.position,
                    this.progress
                );
                this.mesh.position.copy(pos);

                // Update trail
                const trailStart = Math.max(0, this.progress - 0.15);
                const trailPos = new THREE.Vector3().lerpVectors(
                    this.startNode.position,
                    this.endNode.position,
                    trailStart
                );

                const positions = this.trail.geometry.attributes.position.array;
                positions[0] = trailPos.x;
                positions[1] = trailPos.y;
                positions[2] = trailPos.z;
                positions[3] = pos.x;
                positions[4] = pos.y;
                positions[5] = pos.z;
                this.trail.geometry.attributes.position.needsUpdate = true;

                // Fade effects
                const fadeIn = Math.min(this.progress / 0.1, 1);
                const fadeOut = this.progress > 0.85 ? 1 - ((this.progress - 0.85) / 0.15) : 1;
                const alpha = fadeIn * fadeOut;

                this.mesh.material.opacity = alpha;
                this.trail.material.opacity = alpha * 0.5;

                return true;
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.trail);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.trail.geometry.dispose();
                this.trail.material.dispose();
            }
        }

        // Ripple effect class
        class Ripple {
            constructor(node, color) {
                this.node = node;
                this.color = color.clone();
                this.radius = 0;
                this.maxRadius = 1.5;
                this.speed = 0.04;
                this.opacity = 0.8;

                const geometry = new THREE.RingGeometry(0.1, 0.15, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: this.opacity,
                    side: THREE.DoubleSide,
                    toneMapped: false
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(node.position);
                this.mesh.lookAt(camera.position);
                scene.add(this.mesh);
            }

            update() {
                this.radius += this.speed;
                this.opacity *= 0.92;

                const scale = this.radius;
                this.mesh.scale.set(scale, scale, 1);
                this.mesh.material.opacity = this.opacity;
                this.mesh.lookAt(camera.position);

                if (this.opacity < 0.05 || this.radius > this.maxRadius) {
                    return false;
                }
                return true;
            }

            destroy() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Create nodes
        function createNodes(data) {
            const loadingProgress = document.querySelector('.loading-progress');
            loadingProgress.textContent = 'Clustering positions...';

            const positions = contexts.map(ctx => [ctx.vector_x, ctx.vector_y, ctx.vector_z]);
            const clusters = kMeansClustering(positions, 8);
            const colors = getColorPalette();

            loadingProgress.textContent = 'Creating nodes...';

            contexts.forEach((ctx, i) => {
                const position = new THREE.Vector3(ctx.vector_x, ctx.vector_y, ctx.vector_z);
                const clusterColor = colors[clusters[i] % colors.length].clone();

                // Boost saturation
                const hsl = {};
                clusterColor.getHSL(hsl);
                clusterColor.setHSL(hsl.h, 1.0, 0.6);

                const node = new Node(position, clusterColor, i);
                nodes.push(node);
            });

            return clusters;
        }

        // Build connections
        function buildConnections(clusters) {
            const loadingProgress = document.querySelector('.loading-progress');
            loadingProgress.textContent = 'Building connections...';

            const projectGroups = new Map();
            contexts.forEach((ctx, i) => {
                if (!projectGroups.has(ctx.project_id)) {
                    projectGroups.set(ctx.project_id, []);
                }
                projectGroups.get(ctx.project_id).push(i);
            });

            projectGroups.forEach(indices => {
                if (indices.length < 2) return;

                indices.forEach(i => {
                    const pos1 = nodes[i].position;
                    const neighbors = indices
                        .filter(j => j !== i)
                        .map(j => {
                            const pos2 = nodes[j].position;
                            return { index: j, dist: pos1.distanceTo(pos2) };
                        })
                        .sort((a, b) => a.dist - b.dist)
                        .slice(0, 3);

                    neighbors.forEach(({ index: j, dist }) => {
                        if (dist < 5) {
                            connections.push({ from: i, to: j, strength: 1 - (dist / 5) });
                        }
                    });
                });
            });

            // Draw connection lines with vertex colors and shimmer
            connections.forEach(conn => {
                const node1 = nodes[conn.from];
                const node2 = nodes[conn.to];
                
                const positions = new Float32Array(6);
                positions[0] = node1.position.x;
                positions[1] = node1.position.y;
                positions[2] = node1.position.z;
                positions[3] = node2.position.x;
                positions[4] = node2.position.y;
                positions[5] = node2.position.z;

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Per-vertex colors (subtle blend of node colors)
                const c1 = node1.currentColor.clone().multiplyScalar(0.4);
                const c2 = node2.currentColor.clone().multiplyScalar(0.4);
                const colors = new Float32Array([
                    c1.r, c1.g, c1.b,
                    c2.r, c2.g, c2.b
                ]);
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const baseOpacity = conn.strength * 0.06; // Thinner than before
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: baseOpacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    toneMapped: false
                });

                const line = new THREE.Line(geometry, material);
                line.userData = {
                    baseOpacity,
                    shimmerPhase: Math.random() * Math.PI * 2,
                    shimmerSpeed: 0.5 + Math.random() * 0.7
                };
                scene.add(line);
                conn.line = line;
            });
        }

        // Particle spawning
        let lastSpawnTime = 0;
        function spawnParticles() {
            const now = Date.now();
            if (now - lastSpawnTime < PARTICLE_SPAWN_RATE || particles.length >= MAX_PARTICLES) return;
            if (connections.length === 0) return;

            const conn = connections[Math.floor(Math.random() * connections.length)];
            const startNode = nodes[conn.from];
            const endNode = nodes[conn.to];

            const particle = new TravelingParticle(startNode, endNode, startNode.currentColor);
            particles.push(particle);

            lastSpawnTime = now;
        }

        // Update particles and ripples
        function updateParticlesAndRipples() {
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles[i].destroy();
                    particles.splice(i, 1);
                }
            }

            // Update ripples
            for (let i = ripples.length - 1; i >= 0; i--) {
                if (!ripples[i].update()) {
                    ripples[i].destroy();
                    ripples.splice(i, 1);
                }
            }

            document.getElementById('particle-count').textContent = particles.length;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            time = Date.now();
            const deltaTime = 16; // Approximate

            // Update controls
            controls.update();

            // Update nodes
            nodes.forEach(node => node.update(deltaTime, camera.position));

            // Update connection shimmer
            for (const conn of connections) {
                if (conn.line && conn.line.userData) {
                    const ud = conn.line.userData;
                    const shimmer = 0.85 + 0.15 * Math.sin(ud.shimmerPhase + time * 0.001 * ud.shimmerSpeed);
                    conn.line.material.opacity = ud.baseOpacity * shimmer;
                }
            }

            // Spawn and update particles
            spawnParticles();
            updateParticlesAndRipples();

            // Render
            composer.render();

            // FPS counter and adaptive quality
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                frameCountLastSecond = frameCount;
                document.getElementById('fps-count').textContent = frameCount;
                
                // Adaptive particle budget based on FPS
                if (frameCountLastSecond < 55) {
                    MAX_PARTICLES = 40;
                    PARTICLE_SPAWN_RATE = 120;
                    window.bloomPass.strength = 0.6;
                } else if (frameCountLastSecond > 58) {
                    MAX_PARTICLES = 80;
                    PARTICLE_SPAWN_RATE = 80;
                    window.bloomPass.strength = 0.7;
                }
                
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // Controls
        document.getElementById('auto-rotate-btn').addEventListener('click', function() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            this.classList.toggle('active', autoRotate);
        });

        document.getElementById('reset-camera-btn').addEventListener('click', function() {
            camera.position.set(0, 0, 35);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        // Initialize
        async function init() {
            try {
                initScene();
                
                // Create glow texture for particles
                GLOW_TEX = makeGlowTexture();
                
                // Add subtle starfield
                createStarfield();
                
                const data = await loadContextData();
                const clusters = createNodes(data);
                buildConnections(clusters);

                document.getElementById('loading').classList.add('hidden');
                animate();
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }

        init();
    </script>
</body>
</html>