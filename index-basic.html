<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>The Forge Live</title>
  <style>
    body {
      margin: 0;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    #3d-graph {
      width: 100vw;
      height: 100vh;
    }

    .title-overlay {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      text-align: center;
      pointer-events: none;
    }

    .title {
      font-size: 4rem;
      font-weight: 700;
      background: linear-gradient(135deg, #00f5d4, #00d4ff, #7c3aed, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 8px;
    }

    .subtitle {
      font-size: 1.2rem;
      color: #94a3b8;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00d4ff;
      font-size: 1.5rem;
      z-index: 100;
      text-align: center;
      background: rgba(0,0,0,0.9);
      padding: 40px;
      border-radius: 12px;
      border: 2px solid #00d4ff;
    }

    #loading.hidden {
      display: none;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="loading">Loading Mandrel Knowledge Graph...</div>

  <div id="3d-graph"></div>

  <div class="title-overlay">
    <div class="title">The Forge Live</div>
    <div class="subtitle" id="subtitle">Loading...</div>
  </div>

  <script>
    console.log('Starting...');

    // Color palette
    const colors = [
      '#00d4ff', '#10b981', '#ec4899', '#f59e0b',
      '#7c3aed', '#00f5d4', '#0ea5e9', '#fbbf24'
    ];

    // Simple k-means
    function kMeansClustering(points, k = 8, maxIter = 15) {
      const centroids = [];
      const used = new Set();

      while (centroids.length < k && used.size < points.length) {
        const idx = Math.floor(Math.random() * points.length);
        if (!used.has(idx)) {
          centroids.push([...points[idx]]);
          used.add(idx);
        }
      }

      let assignments = new Array(points.length).fill(0);

      for (let iter = 0; iter < maxIter; iter++) {
        for (let i = 0; i < points.length; i++) {
          let minDist = Infinity;
          let best = 0;

          for (let j = 0; j < k; j++) {
            const dist = Math.sqrt(
              Math.pow(points[i][0] - centroids[j][0], 2) +
              Math.pow(points[i][1] - centroids[j][1], 2) +
              Math.pow(points[i][2] - centroids[j][2], 2)
            );
            if (dist < minDist) {
              minDist = dist;
              best = j;
            }
          }
          assignments[i] = best;
        }

        const newCentroids = Array(k).fill(null).map(() => [0, 0, 0]);
        const counts = new Array(k).fill(0);

        for (let i = 0; i < points.length; i++) {
          const c = assignments[i];
          newCentroids[c][0] += points[i][0];
          newCentroids[c][1] += points[i][1];
          newCentroids[c][2] += points[i][2];
          counts[c]++;
        }

        for (let j = 0; j < k; j++) {
          if (counts[j] > 0) {
            centroids[j][0] = newCentroids[j][0] / counts[j];
            centroids[j][1] = newCentroids[j][1] / counts[j];
            centroids[j][2] = newCentroids[j][2] / counts[j];
          }
        }
      }

      return assignments;
    }

    // Load and build graph
    async function init() {
      try {
        console.log('Fetching data...');
        const response = await fetch('./data/contexts.json');
        const data = await response.json();
        const contexts = data.contexts;

        console.log(`Loaded ${contexts.length} contexts`);

        // Cluster
        const positions = contexts.map(c => [c.vector_x, c.vector_y, c.vector_z]);
        const clusters = kMeansClustering(positions, 8);

        // Build graph data - EXACTLY like the example
        const gData = {
          nodes: contexts.map((ctx, i) => ({
            id: ctx.id,
            color: colors[clusters[i]],
            val: 8 // node size
          })),
          links: []
        };

        // Position nodes at UMAP coordinates
        gData.nodes.forEach((node, i) => {
          node.fx = contexts[i].vector_x * 50;
          node.fy = contexts[i].vector_y * 50;
          node.fz = contexts[i].vector_z * 50;
        });

        // Build links
        const projectGroups = new Map();
        contexts.forEach((ctx, i) => {
          if (!projectGroups.has(ctx.project_id)) {
            projectGroups.set(ctx.project_id, []);
          }
          projectGroups.get(ctx.project_id).push(i);
        });

        projectGroups.forEach(indices => {
          if (indices.length < 2) return;

          indices.forEach(i => {
            const node1 = gData.nodes[i];
            const neighbors = indices
              .filter(j => j !== i)
              .map(j => {
                const node2 = gData.nodes[j];
                const dist = Math.sqrt(
                  Math.pow(node1.fx - node2.fx, 2) +
                  Math.pow(node1.fy - node2.fy, 2) +
                  Math.pow(node1.fz - node2.fz, 2)
                );
                return { idx: j, dist };
              })
              .sort((a, b) => a.dist - b.dist)
              .slice(0, 4);

            neighbors.forEach(({ idx, dist }) => {
              if (dist < 250) {
                gData.links.push({
                  source: gData.nodes[i].id,
                  target: gData.nodes[idx].id
                });
              }
            });
          });
        });

        console.log(`Created ${gData.nodes.length} nodes, ${gData.links.length} links`);

        // Update UI
        document.getElementById('subtitle').textContent =
          `${gData.nodes.length} contexts â€¢ ${gData.links.length} connections`;

        // Initialize graph - EXACTLY like the example
        console.log('Creating graph...');
        const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
          .graphData(gData)
          .nodeColor(d => d.color)
          .nodeVal(d => d.val)
          .nodeOpacity(0.95)
          .linkWidth(2)
          .linkOpacity(0.3)
          .linkColor(link => {
            const sourceNode = gData.nodes.find(n => n.id === (link.source.id || link.source));
            return sourceNode ? sourceNode.color : '#00d4ff';
          })
          .linkDirectionalParticles(10)
          .linkDirectionalParticleWidth(6)
          .linkDirectionalParticleSpeed(0.006)
          .linkDirectionalParticleColor(link => {
            const sourceNode = gData.nodes.find(n => n.id === (link.source.id || link.source));
            return sourceNode ? sourceNode.color : '#ffffff';
          });

        // Hide loading
        document.getElementById('loading').classList.add('hidden');
        console.log('Done!');

      } catch (error) {
        console.error('Error:', error);
        document.getElementById('loading').textContent = 'Error: ' + error.message;
      }
    }

    // Start when ready
    window.addEventListener('load', init);
  </script>
</body>
</html>
